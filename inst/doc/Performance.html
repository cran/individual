<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Performance</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Performance</h1>



<div id="toc" class="section level2">
<h2>Table of Contents</h2>
<ol style="list-style-type: decimal">
<li><a href="#intro">Introduction</a></li>
<li><a href="#bitset">Bitset</a></li>
<li><a href="#prefab">Prefabs</a></li>
<li><a href="#cpp_prefab">C++ Prefabs</a></li>
</ol>
</div>
<div id="intro" class="section level2">
<h2>Introduction</h2>
<p>Individual is designed for running big individual-based models. But if you find your model taking too long or consuming all of your memory, here are some things you can try to speed up your simulation.</p>
<div id="bitset" class="section level3">
<h3>Bitset</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Bit_array">bitset</a> data structure is used to record the presence or absence of an element in a finite set. <code>individual::Bitset</code> implements this data structure and is able to preform set operations extremely quickly using <a href="https://en.wikipedia.org/wiki/Bitwise_operation">bitwise operations</a>. Taking advantage of these operations can lead to very fast processes, when you need to find some particular subset of individuals.</p>
<p>Let’s take a look at the recovery process in <code>vignette(&quot;Tutorial&quot;)</code>. A crucial operation here is to get all infectious individuals who are not already scheduled for recovery. The object <code>I</code> is a bitset containing all those individuals currently infectious, and <code>already_scheduled</code> is another bitset containing those individuals scheduled for a recovery event. Using <code>already_scheduled$not()</code> returns a new bitset of those individuals <em>not</em> in the set of already scheduled persons. This is passed to the <code>I$and()</code>, which modifies <code>I</code> in-place so that the result is the intersection of currently infectious persons and persons who have not yet been scheduled for a recovery event, which is precisely the set of people we want.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1">recovery_process &lt;-<span class="st"> </span><span class="cf">function</span>(t){</a>
<a class="sourceLine" id="cb1-2" title="2">  I &lt;-<span class="st"> </span>health<span class="op">$</span><span class="kw">get_index_of</span>(<span class="st">&quot;I&quot;</span>)</a>
<a class="sourceLine" id="cb1-3" title="3">  already_scheduled &lt;-<span class="st"> </span>recovery_event<span class="op">$</span><span class="kw">get_scheduled</span>()</a>
<a class="sourceLine" id="cb1-4" title="4">  I<span class="op">$</span><span class="kw">and</span>(already_scheduled<span class="op">$</span><span class="kw">not</span>())</a>
<a class="sourceLine" id="cb1-5" title="5">  rec_times &lt;-<span class="st"> </span><span class="kw">rgeom</span>(<span class="dt">n =</span> I<span class="op">$</span><span class="kw">size</span>(),<span class="dt">prob =</span> <span class="kw">pexp</span>(<span class="dt">q =</span> gamma <span class="op">*</span><span class="st"> </span>dt)) <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb1-6" title="6">  recovery_event<span class="op">$</span><span class="kw">schedule</span>(<span class="dt">target =</span> I,<span class="dt">delay =</span> rec_times)</a>
<a class="sourceLine" id="cb1-7" title="7">}</a></code></pre></div>
<p>Bitsets can also be efficiently sampled using <code>Bitset$sample()</code>. This is used in the infection process of <code>vignette(&quot;Tutorial&quot;)</code>. Once the per-capita force of infection (probability of moving from S to I during this time step) is calculated, the bitset <code>S</code> is sampled with that probability which modifies it in-place. The number of elements remaining after being sampled is binomially distributed. The argument <code>rate</code> can also be specified as a vector of probabilities, one for each element in the bitset.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">infection_process &lt;-<span class="st"> </span><span class="cf">function</span>(t){</a>
<a class="sourceLine" id="cb2-2" title="2">  I &lt;-<span class="st"> </span>health<span class="op">$</span><span class="kw">get_size_of</span>(<span class="st">&quot;I&quot;</span>)</a>
<a class="sourceLine" id="cb2-3" title="3">  foi &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>I<span class="op">/</span>N</a>
<a class="sourceLine" id="cb2-4" title="4">  S &lt;-<span class="st"> </span>health<span class="op">$</span><span class="kw">get_index_of</span>(<span class="st">&quot;S&quot;</span>)</a>
<a class="sourceLine" id="cb2-5" title="5">  S<span class="op">$</span><span class="kw">sample</span>(<span class="dt">rate =</span> <span class="kw">pexp</span>(<span class="dt">q =</span> foi <span class="op">*</span><span class="st"> </span>dt))</a>
<a class="sourceLine" id="cb2-6" title="6">  health<span class="op">$</span><span class="kw">queue_update</span>(<span class="dt">value =</span> <span class="st">&quot;I&quot;</span>,<span class="dt">index =</span> S)</a>
<a class="sourceLine" id="cb2-7" title="7">}</a></code></pre></div>
<p>When creating a new Bitset, a user must specify the maximum size of the bitset. This is the maximum number of positive integers which the bitset can store. For example, if calling <code>Bitset$new(size = 100)</code>, the resulting object is able to store the presence or absence of integers between 1 and 100 (inclusive). Attempting to insert or remove elements outside of this range will result in an error.</p>
<p>Bitsets offer methods to preform unions (<code>Bitset$or()</code>), intersections (<code>Bitset$and()</code>), symmetric set difference (also known as exclusive or, <code>Bitset$xor()</code>), and set difference (<code>Bitset$set_difference()</code>) with other bitsets. These methods modify the bitset in-place. The method <code>Bitset$not()</code> gives the complement of a bitset, and returns a new <code>individual::Bitset</code> object, leaving the original bitset intact. Because these set operations use bitwise operations directly rather than more expensive relational operators, computations with bitsets are extremely fast. Taking advantage of bitset operations can help make processes in “individual” much faster.</p>
<p>This can be seen when implementing a common pattern in epidemiological models: sampling success or failure for a bitset of individuals, and then generating two bitsets to hold individuals sampled one way or the other. A first method might use <code>individual::filter_bitset</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">n &lt;-<span class="st"> </span><span class="fl">1e4</span></a>
<a class="sourceLine" id="cb3-2" title="2">bset &lt;-<span class="st"> </span>Bitset<span class="op">$</span><span class="kw">new</span>(n)<span class="op">$</span><span class="kw">insert</span>(<span class="dv">1</span><span class="op">:</span>n)</a>
<a class="sourceLine" id="cb3-3" title="3">probs &lt;-<span class="st"> </span><span class="kw">runif</span>(n)</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">keep &lt;-<span class="st"> </span>probs <span class="op">&gt;=</span><span class="st"> </span><span class="fl">0.5</span></a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7">stay &lt;-<span class="st"> </span><span class="kw">filter_bitset</span>(<span class="dt">bitset =</span> bset,<span class="dt">other =</span> <span class="kw">which</span>(keep))</a>
<a class="sourceLine" id="cb3-8" title="8">leave &lt;-<span class="st"> </span><span class="kw">filter_bitset</span>(<span class="dt">bitset =</span> bset,<span class="dt">other =</span> <span class="kw">which</span>(<span class="op">!</span>keep))</a></code></pre></div>
<p>This pattern is almost always slower than using the sample method with a set difference:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">stay &lt;-<span class="st"> </span>bset<span class="op">$</span><span class="kw">copy</span>()</a>
<a class="sourceLine" id="cb4-2" title="2">stay<span class="op">$</span><span class="kw">sample</span>(<span class="dt">rate =</span> probs)</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4">leave &lt;-<span class="st"> </span>bset<span class="op">$</span><span class="kw">copy</span>()<span class="op">$</span><span class="kw">set_difference</span>(stay)</a></code></pre></div>
<p>In both instances the original bitset object <code>bset</code> is not modified. The latter pattern can be made even faster if the original may be modified by directly taking the set difference with it. For models with large population sizes, the speed differences can be substantial.</p>
<p>Because a bitset stores integers in some finite set, it can be returned as an integer vector by using <code>Bitset$to_vector()</code>. However, this is a slow and expensive operation, as data must be copied into a new vector which is returned to R. If your model’s dynamics require the frequent returning of integer vectors, an <code>individual::IntegerVariable</code> object will be more appropriate. However, for most discrete variables, and especially those which mirror compartments in mathematical models, bitset operations and <code>individual::CategoricalVariable</code> (which uses bitsets internally) should be preferred.</p>
</div>
<div id="prefab" class="section level3">
<h3>Prefabs</h3>
<p>Every time your processes ask for a variable, there is an overhead associated with moving simulation data into R, potentially incurring expensive copying of data.</p>
<p>Because many epidemiological models have similar state transitions, we’ve included several “prefab” processes and event listeners implemented in C++ which provide significant speed improvements and can be used out of the box in models. The functions return pointers which can be passed to the process list of <code>individual::simulate_loop</code> or event listeners just like closures in R. The processes available are:</p>
<ul>
<li><code>individual::bernoulli_process</code>: moves individuals from one categorical variable state to another at a constant probability</li>
<li><code>individual::multi_probability_bernoulli_process</code>: moves individuals from one categorical variable state to another at a individual level probability specified by a <code>individual::DoubleVariable</code> object</li>
<li><code>individual::fixed_probability_multinomial_process</code>: moves individuals from one categorical variable state to a set of possible destination values with constant probability to leave and multinomially distributed choice of destination state.</li>
<li><code>individual::multi_probability_multinomial_process</code>: moves individuals from one categorical variable state to a set of possible destination values with individual level probability to leave specified by a <code>individual::DoubleVariable</code> object and multinomially distributed choice of destination state.</li>
<li><code>individual::infection_age_process</code>: Simulates infection for age-structured models, where individuals come into contact at a rate given by a mixing (contact) matrix.</li>
</ul>
<p>Prefabs for event listeners and renderers:</p>
<ul>
<li><code>individual::update_category_listener</code>: event listener for <code>individual::TargetedEvent</code> objects which updates the categorical variable state when it fires.</li>
<li><code>individual::reschedule_listener</code>: event listener for <code>individual::TargetedEvent</code> objects which schedules some new followup event when it fires.</li>
<li><code>individual::categorical_count_renderer_process</code>: used for <code>individual::Render</code> objects that counts the size of each state in a categorical variable.</li>
</ul>
</div>
<div id="cpp_prefab" class="section level3">
<h3>C++ Prefabs</h3>
<p>Unfortunately, we don’t have a prefab for every situation. Please feel free to write one of your own!</p>
<p>These are the basic steps to add C++ processes to your R package:</p>
<ol style="list-style-type: decimal">
<li>Run <code>usethis::use_rcpp</code> to set your package up for C++ development.</li>
<li>Add <code>individual</code> to the <code>LinkingTo</code> section of your package DESCRIPTION.</li>
<li><p>If you package is named <code>mypackage</code>, create a header file containing <code>#include&lt;individual.h&gt;</code> in any of these locations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1">src/mypackage_types.h</a>
<a class="sourceLine" id="cb5-2" title="2">src/mypackage_types.hpp</a>
<a class="sourceLine" id="cb5-3" title="3">inst/include/mypackage_types.h</a>
<a class="sourceLine" id="cb5-4" title="4">inst/include/mypackage_types.hpp</a></code></pre></div>
<p>Then this header file will be automatically included in <code>RcppExports.cpp</code>. For more information, see section “2.5 Types in Generated Code” in the <a href="https://CRAN.R-project.org/package=Rcpp/vignettes/Rcpp-attributes.pdf">Rcpp Attributes vignette</a>.</p></li>
<li>Create a file <code>src/Makecars</code> containing the line <code>CXX_STD = CXX14</code>. Because <code>individual</code> uses C++14 features, when compiling your package against it you must let the compiler know it should use the C++14 standard, otherwise it will not be able to compile.</li>
<li><p>Write your process!</p></li>
</ol>
<p>Processes in C++ are of type <code>process_t</code>, defined in <code>inst/include/common_types.h</code>. Types for listeners for <code>individual::Event</code> and <code>individual::TargetedEvent</code> are <code>listener_t</code> and <code>targeted_listener_t</code>, defined in <code>inst/include/Event.h</code>. Below is how the C++ implementation of <code>multi_probability_bernoulli_process</code> is coded.</p>
<p>Note that the return type is a <code>Rcpp::XPtr</code> <a href="https://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1XPtr.html">(see here)</a> to a <code>process_t</code>, which is implemented as a <code>std::function</code> <a href="https://cplusplus.com/reference/functional/function/">(see here)</a> object, a C++ class that can hold any callable type. The <code>Rcpp::XPtr</code> is initialized with a pointer to a <code>process_t</code> object, which itself holds a C++ <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda function</a>, basically a function closure.</p>
<p>The lambda function captures the input arguments by value, and takes a single argument when called <code>t</code>, giving the current time step (just like process functions in R). Sampling those individuals to change state is implemented with the C++ API for these objects.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include </span><span class="im">&lt;individual.h&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span></a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb6-5" title="5">Rcpp::XPtr&lt;<span class="dt">process_t</span>&gt; multi_probability_bernoulli_process_cpp(</a>
<a class="sourceLine" id="cb6-6" title="6">    Rcpp::XPtr&lt;CategoricalVariable&gt; variable,</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="at">const</span> <span class="bu">std::</span>string from,</a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="at">const</span> <span class="bu">std::</span>string to,</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="at">const</span> Rcpp::XPtr&lt;DoubleVariable&gt; rate_variable</a>
<a class="sourceLine" id="cb6-10" title="10">){</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="co">// make pointer to lambda function and return XPtr to R</span></a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="cf">return</span> Rcpp::XPtr&lt;<span class="dt">process_t</span>&gt;(</a>
<a class="sourceLine" id="cb6-14" title="14">        <span class="kw">new</span> <span class="dt">process_t</span>([variable,rate_variable,from,to](<span class="dt">size_t</span> t){      </a>
<a class="sourceLine" id="cb6-15" title="15"></a>
<a class="sourceLine" id="cb6-16" title="16">            <span class="co">// sample leavers with their unique prob</span></a>
<a class="sourceLine" id="cb6-17" title="17">            <span class="dt">individual_index_t</span> leaving_individuals(variable-&gt;get_index_of(<span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt;{from}));</a>
<a class="sourceLine" id="cb6-18" title="18">            <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; rate_vector = rate_variable-&gt;get_values(leaving_individuals);</a>
<a class="sourceLine" id="cb6-19" title="19">            bitset_sample_multi_internal(leaving_individuals, rate_vector.begin(), rate_vector.end());</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21">            variable-&gt;queue_update(to, leaving_individuals);</a>
<a class="sourceLine" id="cb6-22" title="22"></a>
<a class="sourceLine" id="cb6-23" title="23">        }),</a>
<a class="sourceLine" id="cb6-24" title="24">        <span class="kw">true</span></a>
<a class="sourceLine" id="cb6-25" title="25">    ); </a>
<a class="sourceLine" id="cb6-26" title="26">};</a></code></pre></div>
<p>The exported function can be used normally in R when creating the list of processes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1">processes &lt;-<span class="st"> </span><span class="kw">list</span>(</a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="kw">multi_probability_bernoulli_process_cpp</span>(state, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>, prob),</a>
<a class="sourceLine" id="cb7-3" title="3">  other_process_<span class="dv">1</span>,</a>
<a class="sourceLine" id="cb7-4" title="4">  other_process_<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-5" title="5">)</a></code></pre></div>
<p>That’s everything you need to scale your models up to millions of individuals!</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
